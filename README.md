# designpattern
## Iterator
- これはvectorなどの集約体の種類による走査方法の制約を受けずに前から1つつずつ操作したい場合に用いる
## Adapter
- あらかじめメソッドを考えておき、それを実現するメソッドを新しく変更できる。organizeClassの中身を変えることでインターフェースの変更を吸収できる
## TemplateMethod
- メソッドを決めておき、実装を後から行う
## FactoryMethod
- 操作するインスタンスの種類をコンストラクタを工夫することで変更可能にする
## Singleton
- クラスのインスタンスが1つしかないことを保証する
## Prototype
- 複雑な操作がなされたインスタンスをコピーすることができる。大量の操作済みインスタンスのコピー
## Builder
- 操作の過程が同じで操作対象や方法が複数種類あるとき。この例ではDirectorは水溶液をどのように操作するのか(40g溶かす)を定義、Builderは何を操作するかと操作方法(砂糖を溶かすとは？を定義)を定義する。
## AbstractFactory
- 工場のような一連の作業を抽象化して、商品ごとに具体的な作業内容を決めるというもの
## Bridge
- 継承して新しいメソッドを追加するときに、継承元から継承されてオーバーライドされた関数を読みたいとき、機能と実装の分離
## Strategy
- if文で分岐させるメソッドではなく、アルゴリズムのメソッド中身の変更を柔軟にする
## Composite 
- 容器(Directory)と中身(File)を同一視して同じインターフェースから派生させる。再帰的な処理をさせたいとき
## Decorator
- 中身と装飾を同一視することで包む形で追加実装を柔軟に行うことができる
## Visitor
- 受け入れ側に処理を追加することなく、処理の追加ができる。Acceptorにaccept関数を作っておいて、外部のクラスの処理をさせる
## Chain of Responsibility
- レベル別などで順番に処理を渡していき、適合するレベルで処理できる
## Facade
- AbstractFactoryの具体例、窓口が操作をすべて代行する
## Mediator
- 様々なクラスを同時に管理するクラス(仲裁者)を作成して、複雑クラスの絡み合う条件で発動させるなどの処理ができる